# ch02 - 数据类型

## non-leaf

在计算机科学中，特别是在函数调用和执行栈的上下文中，“leaf”函数指的是一个不会调用其他函数的函数。
相对地，“non-leaf”函数是指那些在其执行过程中会调用一个或多个其他函数的函数。

这个区分主要是出于性能和调用约定的考虑。Leaf 函数因为不会进行进一步的函数调用，
所以它们的执行通常相对简单直接，可能不需要保存那么多的调用状态（比如寄存器内容），
并且在某些情况下可以优化去除帧指针（frame pointer）以节省栈空间或者减少入栈和出栈操作。
这样的优化对于嵌入式系统或者对性能有极高要求的应用尤其重要。

相反，non-leaf 函数由于需要调用其他函数，它们必须能够正确地保存和恢复调用状态，
包括参数、局部变量和寄存器状态等，以保证被调用函数执行完毕后能够正确地返回并继续执行。
这通常意味着需要更复杂的栈管理和使用帧指针来访问函数的局部变量和参数。

在一些编译器优化和函数属性的设置中，会看到对 leaf 和 non-leaf 函数的区分。
比如，某些优化可能只适用于 leaf 函数，而在 non-leaf 函数中则需要保留帧指针以支持更复杂的调用栈操作。

## 栈保护

栈保护（Stack Protection）是一种安全技术，用于防止栈溢出攻击，
这种攻击可能会覆盖栈上的返回地址或其他重要的数据，从而允许攻击者控制程序的执行流程。
栈保护技术的目的是在函数调用的栈帧中引入一种机制，用以检测和防止这种未授权的访问或修改。

实现栈保护的一种常见方式是使用“栈护卫变量”（也称为“canary”），它的工作原理如下：

### 栈护卫变量（Canary）

1. **插入 Canary**：编译器在生成函数调用的代码时，
   在局部变量和控制数据（如返回地址）之间插入一个随机生成的值，称为栈护卫变量或“canary”。
   这个值在函数入口处被放置，并在函数退出前检查其值是否被篡改。

2. **检查 Canary**：在函数返回前，程序会检查这个栈护卫变量的值是否改变。
   如果发现这个值被篡改（通常意味着有一个栈溢出尝试覆盖了返回地址），程序会终止执行，
   通常是通过抛出一个异常或执行一个安全的终止序列。

### 栈保护的效果

通过这种方式，栈保护技术能够有效地防止一类常见的攻击：
攻击者试图通过溢出错误（例如，向一个局部数组写入过多数据）来覆盖函数的返回地址或其他重要控制数据。
通过检查栈护卫变量的完整性，这种攻击可以在造成更严重损害前被检测到和阻止。

### 栈保护的局限

尽管栈保护是一个强大的安全特性，但它并不是万能的。
它主要针对栈溢出攻击，对于其他类型的漏洞（如堆溢出、整数溢出、逻辑错误等）并无帮助。
此外，一些高级的攻击技术可能会尝试绕过栈护卫变量的检查。

### 在编译器中的支持

许多现代编译器，如 GCC 和 Clang，提供了栈保护的选项。
例如，在 GCC 中，可以通过`-fstack-protector`、`-fstack-protector-strong`等选项来启用栈保护特性。
这些选项控制编译器在哪些函数中插入栈护卫变量以及如何检查它们。

栈保护是现代软件安全策略的一个重要组成部分，有助于提升应用程序对抵抗攻击的能力。
